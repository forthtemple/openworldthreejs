<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Second Temple</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body{
				color: #000;
				font-family:Arial;
				font-size:18px;
				text-align:center;
				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			input {
				color: grey;
				font-family:Arial;
				font-size:18px;
				itext-align:center;
				ibackground-color: #fff;
				background-color:rgba(0,0,0,0);
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				float:right;
				padding: 0px;
				iwidth: 100%;
				right:0px;
				text-align: right;
				color: grey;
			}

			a { color: #bfbfbf; }
			
			#progress {
				color:grey;
				top:10em;
				width: 100%;
				font-family:Arial;
				position:absolute;
				z-index:100;
				text-align: center;
				display:none;
			}

			.shadow {
				-moz-box-shadow: 0px 0px 5px #000;
				-webkit-box-shadow: 0px 0px 5px #000;
				box-shadow: 0px 0px 5px #000;
			}

			#progressbar {
				text-align: center;
				background: white;
				width: 250px;
				height: 10px;
			}

			#bar {
				background:grey;
				width:50px;
				height:10px;
				margin-top:10px;
			}		

			#messages {
				position:fixed; 
				bottom:0; 
				/*width:200px;*//*100%; */
				/*text-align:right;*/
				color:grey;
				margin-bottom:10px;
			}	
			#nameoverlay {
			    display:none;
			    position: absolute;
			    margin-bottom:100px;
			   imargin-right:10px;
			    ifloat:right;
			    right: 0px;
			    iitop: 0px;
			    width:315px;
			    height:90px;
			    iwidth:100%;
			    iheight:100%;
			    text-align:center;
			    ibackground:white;
			    border: solid 2px grey;
			 }

			
		</style>
	</head>

	<body>
		<div id="info">
			<div id="title">
				<b><span dir="rtl" xml:lang="he" lang="he">בֵּית־הַמִּקְדָּשׁ הַשֵּׁנִי</span></b><br>
				<span id="info2">
				<b>Second Temple</b><br>
				Use arrows to move<br>
				Mouse for camera
				</span>
			</div>
			<div id="configall" style="margin-top:2px">	   
			    <img src="icons/disconnect.png"  id="disconnect" style="display:none"/>
				<img src="icons/config.png"  id="config" style="margin-right:0px" />
				<div style="display:none; margin-bottom:7px" id="configdiv">
					<a href="#" onclick="var win = window.open('http://www.forthtemple.com', '_blank'); ">Forth Temple</a><br>
					Get it on <a href="#" onclick="var win = window.open('https://github.com/forthtemple/openworldthreejs', '_blank'); ">Github</a><br>

					<input type="button" value="Fullscreen" id="fullscreen" style="margin-right:3px; font-size:10px; border:1px grey solid"/><br>					
					<input type="button" value="Stats" id="stats" style="margin-right:3px; font-size:10px; border:1px grey solid"/>					

				</div>
            </div>

			<div id="nameoverlay">
				<input type="button" value="x" id="closename" style="float:right; font-size:10px"/>
			     <br><div id="promptext">Enter you name: </div>
			     <div id="nametext">
			      		<input style="color:white; z-index: 1000;" type="text" id="name" value="Aral"  /> <input type="button" id="go" value="Go" istyle="ipadding-left:-15px; margin-left:-15px"/>
			     </div>

			</div>

 			<input type="button" id="connect" value="Connect" style="margin-top:3px; margin-right:2px"/><br>

		 	<div id="actionbuttons" style="display:none">
						<img src="icons/who.png"  id="who"  title="Who's playing"/>
						<img src="icons/msg.png"  id="speak" title="Say something" />
						<img src="icons/wave.png"  id="action" title="Wave at other players"/>
			</div>			

			<div id="wholist" style="iposition:absolute; right:0px; margin-top:20px">
			</div>	

			<div   style="display:none" id="fly">
				<br><br>
				<img src="icons/arrow.png"  id="flyup"  /><br>
				<img src="icons/wings.png"  iid="fly" /><br>
				<img src="icons/arrow.png"  id="flydown"  style="-moz-transform: scaleY(-1); -o-transform: scaleY(-1);  -webkit-transform: scaleY(-1); transform: scaleY(-1);  filter: FlipV;   -ms-filter: 'FlipV';"/>
			</div>
			
		</div> <!--info-->
		<div id="messages">
		</div>
		<div id="progress">
			<span id="message" >Loading ...</span>

			<center>
				<div id="progressbar" class="shadow"><div id="bar" class="shadow"></div></div>
			</center>
		</div>
		
		
        <script src="build/three.min.js"></script>

		<script src='js/Gyroscope.js'></script>
		<script src="js/loaders/MTLLoader.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>
	
		<script src="openworldjs/VolumetricFire.js"></script>
		<script src="openworldjs/OpenWorld.js"></script>
	
		<script src="js/SkyShader.js"></script>
		<script src='js/Detector.js'></script>
		<script src='js/libs/stats.min.js'></script>


		<script>

			var system=new OPENWORLD.System();
			var ismobile=system.detectMobile();
			if (ismobile) {
				document.getElementById('info2').innerHTML="<b>Second Temple</b><br>Use virtual joystick<br>to move<br>Touch screen to turn";
			} else {
			}
			var omath=new OPENWORLD.Math();
			var osound=new OPENWORLD.Sound();
			var otouchscreen;
			
			//var fog=false;
			
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			var container,  scene, renderer;
			var camera;
			var cameraoffset=0.15;
			
			var cameraControls;

			var sky, sunSphere;

			var effectController;

		    var mouse = new THREE.Vector2();

			var clock = new THREE.Clock();
			
			var joystick;

			var targetRotationX = 0;
			var targetRotationY = 0;

			var mouseX = 0;
			var mouseY = 0;
			var fire;


			var light;
			var listener;
			
			var mixershofar;
			var mixershofar2;
			var shofar;
			var shofar2;
			var lightshofar;
			
			var priest;
			var mixerpriest;
			
			var cow;
			var mixercow;
			var cowtick=-1;
			
			var ark;
			
			var sound1;
			var sound2;

			var TS_SHOFAR=0;
			var TS_PRIEST=1;
			var TS_PRIEST_BLESSING=2;
			var TS_COW=3;
			var TS_COW_REMOVE=4;
			var TS_ARK_ADD=5;
			var TS_ARK_FLARE_ADD=6;
			var TS_ARK_FLARE_ADD2=7;
			var TS_ARK=8;
			var templestate=TS_SHOFAR;

			var space;
			
			var loadedmodel=0;
			var totalmodel=-1;
			var loadedshofar=0;
			var totalshofar=-1;
			
			
			var cubeCamera2;	
			var umaterial;
			
			var sprites = [];
		
		    var player_mixers = [];
		    var player_mixers_removed =[];

		    var CS_NONE=0;
		    var CS_GET_NAME=1;
		    var CS_CONNECTING=2;
		    var CS_CONNECTED=3;
		    var connect_state=CS_NONE;

		    var stats=0;
			
						
			// function for drawing rounded rectangles
			function roundRect(ctx, x, y, w, h, r) 
			{
				ctx.beginPath();
				ctx.moveTo(x+r, y);
				ctx.lineTo(x+w-r, y);
				ctx.quadraticCurveTo(x+w, y, x+w, y+r);
				ctx.lineTo(x+w, y+h-r);
				ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
				ctx.lineTo(x+r, y+h);
				ctx.quadraticCurveTo(x, y+h, x, y+h-r);
				ctx.lineTo(x, y+r);
				ctx.quadraticCurveTo(x, y, x+r, y);
				ctx.closePath();
				ctx.fill();
				ctx.stroke();   
			}		
			// Alignment enums

			THREE.SpriteAlignment = {};
			THREE.SpriteAlignment.topLeft = new THREE.Vector2( 1, -1 );
			THREE.SpriteAlignment.topCenter = new THREE.Vector2( 0, -1 );
			THREE.SpriteAlignment.topRight = new THREE.Vector2( -1, -1 );
			THREE.SpriteAlignment.centerLeft = new THREE.Vector2( 1, 0 );
			THREE.SpriteAlignment.center = new THREE.Vector2( 0, 0 );
			THREE.SpriteAlignment.centerRight = new THREE.Vector2( -1, 0 );
			THREE.SpriteAlignment.bottomLeft = new THREE.Vector2( 1, 1 );
			THREE.SpriteAlignment.bottomCenter = new THREE.Vector2( 0, 1 );
			THREE.SpriteAlignment.bottomRight = new THREE.Vector2( -1, 1 );

			// Make sprite above players head			
			function makeTextSprite( message, parameters , textcolor)
			{
				if ( parameters === undefined ) parameters = {};
				
				var fontface = parameters.hasOwnProperty("fontface") ? 
					parameters["fontface"] : "Arial";
				
				var fontsize = parameters.hasOwnProperty("fontsize") ? 
					parameters["fontsize"] : 18;
				
				var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
					parameters["borderThickness"] : 4;
				
				var borderColor = parameters.hasOwnProperty("borderColor") ?
					parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
				
				var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
					parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

				var spriteAlignment = THREE.SpriteAlignment.topLeft;
					
				var canvas = document.createElement('canvas');
				var context = canvas.getContext('2d');
				context.font = "Bold " + fontsize + "px " + fontface;
			   // context.marginLeft="20px";
				// get size data (height depends only on font size)
				var metrics = context.measureText( message );
				var textWidth = metrics.width;
				
				// background color
				context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
											  + backgroundColor.b + "," + backgroundColor.a + ")";
				// border color
				context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
											  + borderColor.b + "," + borderColor.a + ")";

				context.lineWidth = borderThickness;
				roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
				// 1.4 is extra height factor for text below baseline: g,j,p,q.
				
				// text color
				context.fillStyle = textcolor;//"rgba(255, 255, 0, 1.0)";
				//context.textAlign="center";
				context.fillText( message, borderThickness+textWidth, fontsize + borderThickness);
				
				// canvas contents will be used for a texture
				var texture = new THREE.Texture(canvas) 
				texture.needsUpdate = true;

				var spriteMaterial = new THREE.SpriteMaterial( 
					{ map: texture, useScreenCoordinates: false, alignment: spriteAlignment } );
				var sprite = new THREE.Sprite( spriteMaterial );
				sprite.scale.set(100,50,1.0);
				sprite.position.y=30;  
				return sprite;	
			}			
						

			function $( id ) {

				return document.getElementById( id );

			}
			
			// Play the shofar
			function animateShofar()
			{
				if (!mixershofar)
					mixershofar = new THREE.AnimationMixer( shofar );
				mixershofar.clipAction( shofar.geometry.animations[2] ).reset();
				mixershofar.clipAction( shofar.geometry.animations[2] ).clampWhenFinished=true;
				mixershofar.addEventListener('finished',function(e){
					if (connect_state!=CS_CONNECTED) {
						sound1.play();
						mixershofar.clipAction( shofar.geometry.animations[1] ).reset();
						mixershofar.clipAction( shofar.geometry.animations[1] ).play();
				    }
				});  
				if (!mixershofar2)
					mixershofar2 = new THREE.AnimationMixer( shofar2 );
				mixershofar2.clipAction( shofar2.geometry.animations[2] ).reset();
				mixershofar2.clipAction( shofar2.geometry.animations[2] ).clampWhenFinished=true;
				//this.clampWhenFinished
				mixershofar2.addEventListener('finished',function(e){
					if (connect_state!=CS_CONNECTED) {

					//play('Idle',true);
						mixershofar2.clipAction( shofar2.geometry.animations[1] ).reset();
						mixershofar2.clipAction( shofar2.geometry.animations[1] ).play();
				    }
				});	
				if (sound1.isPlaying)
					sound1.stop();

				var audioLoader = new THREE.AudioLoader();
				audioLoader.load( 'sounds/shofar.mp3', function( buffer ) {
					sound1.setBuffer( buffer );
					sound1.setRefDistance( 20 );
					sound1.setVolume(0.25);
					// only animate once sound loaded
					mixershofar.clipAction( shofar.geometry.animations[2] ).setDuration( 1 ).setLoop(THREE.LoopOnce).play();
					mixershofar2.clipAction( shofar2.geometry.animations[2] ).setDuration( 0.9 ).setLoop(THREE.LoopOnce).play();
					sound1.source.onended = function() {
						if (connect_state!=CS_CONNECTED&&(templestate==TS_SHOFAR||templestate==TS_ARK)) {
							mixershofar.clipAction( shofar.geometry.animations[0] ).setDuration(0.95).setLoop(THREE.LoopOnce);//setEffectiveTimeScale(-1);
							mixershofar.clipAction( shofar.geometry.animations[0] ).reset();
							mixershofar.clipAction( shofar.geometry.animations[0] ).play();
							mixershofar2.clipAction( shofar2.geometry.animations[0] ).setDuration(1).setLoop(THREE.LoopOnce);//setEffectiveTimeScale(-1);
							mixershofar2.clipAction( shofar2.geometry.animations[0] ).play();
							mixershofar.addEventListener('finished',function(e){
								mixershofar.clipAction( shofar.geometry.animations[3] ).reset();
								mixershofar.clipAction( shofar.geometry.animations[3] ).play();
							});							
							mixershofar2.addEventListener('finished',function(e){
								mixershofar2.clipAction( shofar2.geometry.animations[3] ).reset();
								mixershofar2.clipAction( shofar2.geometry.animations[3] ).play();
							});		
						}
						this.isPlaying = false;  /* sets Three wrapper property correctly */
					};
					//sound1.play();
				});				
			}
			
  
			function config() {
				if ($( "configdiv" ).style.display=="none")
					$( "configdiv" ).style.display = "";
				else
					$( "configdiv" ).style.display = "none";
			}
			
			// Tell server waving
			function action() {
				camera._action="wave";
			}

			// Called when you click the connect/disconnect button
			// if clicking connect then ask the users name
			// if clicking disconnect then signal disconnect
			function get_name()
			{
				if (connect_state==CS_CONNECTED) {
	 				camera._disconnect=true;
					//connect_state=CS_NONE;
                } else {
                	$("nametext").style.display="block";//visibility="visible";
	  				$( "title").style.display="none";
	  				                	//$("go").style.display="block";

	   				//$("configall").style.marginTop="100px";//visibility="visible";

	   				$("nameoverlay").style.display="block";//visibility="visible";
                    var names=["Phannias","Mattathias","Joshua","Ananus","Joseph","Ishmael","Jonathan","Ananias","Josephus","Elioneus","Matthias","Simon","Theophilus","Eleazar","Joazer","Ananelus","Antigonus","Simeon","Jason","Onias","Johannan","Joiada","Eliashib","Joiakim","Ezra","Joshua" ];
	   				$("name").focus();
                    $("name").value='';
		            $("name").value=names[Math.floor(Math.random()*names.length)];
                    $("connect").style.display="none";
	                $("messages").innerHTML="";
	   				//$("name").selectStart=$("name").selectionEnd=$("name").value.length;

	   				this_active=false;
					connect_state=CS_GET_NAME;
				}
			}

			// when hit that x to close the box
			function closename()
			{
				$("nameoverlay").style.display="none";
                $("connect").style.display="block";
                $("connect").style.float="right";
                $("nameoverlay").style.marginTop="40px";
				$("actionbuttons").style.marginTop="40px";
				this_active=true;
				if (connect_state!=CS_CONNECTED) 
					connect_state=CS_NONE;

			}
			
			// Stop all animations on character
			function animationstop(mixer)
			{
				for (j=0; j<mixer._root.geometry.animations.length; j++) {
					mixer.clipAction( mixer._root.geometry.animations[j] ).stop();
					mixer.clipAction( mixer._root.geometry.animations[j] ).reset();
				}

			}
			
			// This is when you click the 'go' button in name so can be either entering your name or entering a message
			// Should really be two functions
			function connect()
			{
				// this is bad, 'go' should have different handlers
				if (connect_state==CS_CONNECTED) {
					msg();
				} else {
					this_active=true;
	   				//el.style.visibility =  "hidden";
	  				$( "who" ).style.visibility="visible";
	  				$( "speak" ).style.visibility="visible";

	  				//$("connect").value="Disconnect";//style.visibility="hidden";
	 				$("promptext").innerHTML="Connecting...";
	 				camera._name=$("name").value;
	 				$("name").blur();
	 				$("nametext").style.display="none";
 				    //$("go").style.display="none";

	 				msgs=[];
	 				whos=[];
					for (i=0; i<player_mixers.length; i++) {
						animationstop(player_mixers[i]);
						player_mixers[i].clipAction( player_mixers[i]._root.geometry.animations[3] ).setDuration(3).play();

					}

	  				connect_state=CS_CONNECTING;
	  			}	
			}

			// Change layout and stop polling server
			function disconnect()
			{
				   	$("nameoverlay").style.display="none";//visibility="hidden";
	  				$("connect").value="Connect";//style.visibility="hidden";
	 				$("promptext").innerHTML="Enter Name";
	 				$("actionbuttons").style.display="none";
	 				$("wholist").innerHTML="";
	 				connect_state=CS_NONE;

			}

			// Once has connected to server change layout
			function has_connected()
			{
				$("nameoverlay").style.display="none"; 
				$("action").style.display="block"; 
				$("action").style.float="right"; 
				$("actionbuttons").style.display="block";
			    $("actionbuttons").style.marginTop="25px";//visibility="visible";
			    $("connect").style.display="block";
			    $("promptext").innerHTML="Enter message:"
	 			$("nametext").style.display="block";
	 			$("name").value="";

			    $("connect").style.right='0px';
			    $("connect").style.position='absolute';
	  			$("connect").value="Disconnect";//style.visibility="hidden";


			}
			
			// Message to server
			function speak()
			{
				this_active=false;
				$("actionbuttons").style.marginTop="125px";
				$("nameoverlay").style.marginTop="40px";
   				$("nameoverlay").style.display="block";//visibility="visible";
   				$("name").focus();
			}
			
			// Tell server to list who's on
			function who()
			{
				camera._who=true;
			}

			function msg()
			{
 				this_active=true;
 				$("name").blur();// get rid of smart phone keyboard
				$("actionbuttons").style.marginTop="40px";
				//joystick._active=false;
				//otouchscreen._active=false;
				camera._msg.push($("name").value);
				$("name").value="";
				$("nameoverlay").style.marginTop="40px";
				$("nameoverlay").style.display="none";//visibility="hidden";

			}

			function fog()
			{
				scene.fog = new THREE.Fog( 0xffffff, 1, 4 );	
			}

			// Make fullscreen
			function fullscreen()
			{
				var el = document.documentElement
					    , rfs = // for newer Webkit and Firefox
					           el.requestFullScreen
					        || el.webkitRequestFullScreen
					        || el.mozRequestFullScreen
					        || el.msRequestFullscreen
					;
				if(typeof rfs!="undefined" && rfs)
				  rfs.call(el);
			
			}

			function statsshow()
			{
				if (stats) {
					container.removeChild(stats.dom);
					stats=null;
				} else {
					stats = new Stats();
					container.appendChild( stats.dom );
			    }

			}

			init();
			
			animate();
			
			function init() {
			

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
  
				// CAMERA
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 2000000 );
				camera.eulerOrder = "YXZ";

				camera._msg=[];
				camera._action="";
				camera._who=0;
				camera._disconnect=0;
				// SCENE
				scene = new THREE.Scene();
				camera.position.y=999;
				//if (fog)
				//	scene.fog = new THREE.Fog( 0xffffff, 1000, 4000 );	
				scene.add( camera );
                //camera.position.y=100000;
				// LIGHTS

				scene.add( new THREE.AmbientLight( 0x222222 ) );

				listener = new THREE.AudioListener();
				camera.add( listener );
				
				sound1 = new THREE.PositionalAudio( listener );
				sound2 = new THREE.PositionalAudio( listener );

				
				scene.add( sound1 );			
				scene.add(sound2);
		
				// RENDERER
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				//renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				container.appendChild( renderer.domElement );
 				//

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

		
			   
				// STATS

				//stats = new Stats();
				//container.appendChild( stats.dom );

				// EVENTS

				window.addEventListener( 'resize', onWindowResize, false );
				
				otouchscreen=new OPENWORLD.Touchscreen();
	

				sky = new THREE.Sky();
				scene.add( sky.mesh );

				// Add Sun Helper
				sunSphere = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 20000, 16, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xffffff } )
				);
				sunSphere.position.y = - 700000;
				sunSphere.visible = true;
				scene.add( sunSphere );


				var onError = function ( xhr ) { };
				
				// Load the temple
				var mtlLoader = new THREE.MTLLoader();
				mtlLoader.setPath( 'models/temple/' );
				mtlLoader.load( 'temple.mtl', function( materials ) {

					materials.preload();

					var objLoader = new THREE.OBJLoader();
					objLoader.setMaterials( materials );
					objLoader.setPath( 'models/temple/' );
					objLoader.load( 'temple.obj', function ( object ) {	
						// Once you have loaded the temple you now have the surfaces to place objects on top of
						space = new OPENWORLD.Space(object);
						scene.add( object );
						// Place the camera in world coords at 8.59, 1.31 on the surface
						space.worldToLocalSurfaceObj(camera,8.59,1.31,0.15);
						// Initially look at the temple
						camera.lookAt(space.worldToLocal(0,1.31,0));
						
						joystick = new VirtualJoystick({
							mouseSupport	: true,
							stationaryBase	: true,
							baseX		: 70,
							baseY		: 70,
							strokeStyle : 'grey',
							limitStickTravel:true,

						}, camera, space);
					
						$( "config" ).addEventListener( 'touchstart', config);
						$( "config" ).addEventListener( 'click', config);

						$( "action" ).addEventListener( 'touchstart', action);
						$( "action" ).addEventListener( 'click', action);

						$( "who" ).addEventListener( 'touchstart', who);
						$( "who" ).addEventListener( 'click', who);
						$( "who" ).style.visibility="hidden";
						$( "connect" ).addEventListener( 'touchstart', get_name);
						$( "connect" ).addEventListener( 'click', get_name);
						$( "speak" ).style.visibility="hidden";
						$( "speak" ).addEventListener( 'touchstart', speak);
						$( "speak" ).addEventListener( 'click', speak);
						$( "closename" ).addEventListener( 'touchstart', closename);
						$( "closename" ).addEventListener( 'click', closename);
						$( "go" ).addEventListener( 'touchstart', connect);
						$( "go" ).addEventListener( 'click', connect);
						//$( "fog" ).addEventListener( 'change', fog);
						$( "fullscreen" ).addEventListener( 'touchstart', fullscreen);
						$( "fullscreen" ).addEventListener( 'click', fullscreen);
						$( "stats" ).addEventListener( 'touchstart', statsshow);
						$( "stats" ).addEventListener( 'click', statsshow);

					    $("name").onkeypress= function(e){
							if (!e) e=window.event;
							var keyCode = e.keyCode || e.which;
							if (keyCode=='13') {
								////alert('voot');
								if (connect_state==CS_GET_NAME)
									connect();
							    else
							    	msg();
								return false;
							}
						}
	
						// Light up the temple with spotlight				
						light = new THREE.SpotLight(0xffffff);
						light.intensity  = 2;
						light.penumbra =1;
						space.worldToLocalObj(light,3,1.3,7);
						scene.add( light );
	
						// Show the altar fire
						VolumetricFire.texturePath = 'openworldjs/VolumetricFireTextures/';

						var fireWidth  = 2;
						var fireHeight = 4;
						var fireDepth  = 2;
						var sliceSpacing = 0.5;

						fire = new VolumetricFire(
						  fireWidth,
						  fireHeight,
						  fireDepth,
						  sliceSpacing,
						  camera
						);
						space.worldToLocalSurfaceObj(fire.mesh,3.35,0.51,0.3);//3.7);
						fire.mesh.scale.x=0.25;
						fire.mesh.scale.y=0.25;
						fire.mesh.scale.z=0.25;
						scene.add( fire.mesh );

						
						loadedmodel=-2;

						callbackFinished();
						
						// Show the two shofars
						var geometry = new THREE.PlaneBufferGeometry( 16000, 16000 );
						//var material = new THREE.MeshPhongMaterial( { emissive: 0x220000 } );
						var loader = new THREE.JSONLoader();

						loader.load( "actors/shofar/shofar.json", function ( geometry, materials ) {
						
							for ( var k in materials ) {
								materials[k].skinning = true;

							}

							shofar = new THREE.SkinnedMesh(geometry,new THREE.MultiMaterial(materials));

							shofar.scale.set( 0.004, 0.004, 0.004);
							// 
							space.worldToLocalSurfaceObj(shofar,7.7,2,0.14);//3.42);
							shofar.skeleton.useVertexTexture = false;					
							shofar2=shofar.clone();
							texture=THREE.ImageUtils.loadTexture("actors/shofar/shofar2.jpg");
							shofar2.material=shofar.material.clone();
							shofar2.material.materials[0]=new THREE.MeshLambertMaterial({map:texture});
							shofar2.material.materials[0].skinning=true;									
							space.objTurn(shofar,180);
							scene.add( shofar );	


							space.worldToLocalSurfaceObj(shofar2,7.7,0.7,0.14);//3.42);							
							space.objTurn(shofar2,0);
							scene.add( shofar2 );	
                            animateShofar();
							player_mixers.push(mixershofar);
							player_mixers.push(mixershofar2);
								
							// Put a spot light on both shofars
							lightshofar = new THREE.SpotLight(0xffffff);//PointLight(0xffffff)
							lightshofar.intensity  = 0.6;
							lightshofar.angle=0.5;
							lightshofar.penumbra =0.5;
							lightshofar.position.set( 8.59,5,-1.3);//200, 450, 500 );
							var dummy=new THREE.Object3D() ;
							dummy.position.set(7.7,3.42,-1.3);
							scene.add(dummy);
							lightshofar.target=dummy;//shofar;
							scene.add(lightshofar );
													
							
							loadedshofar=-2;
							callbackFinished();
			
							}
						 , shofarprogress, onError );

						}, callbackProgress, onError );

				});

				// Show the sky
			    effectController  = {
					turbidity: 10,
					reileigh: 2,
					mieCoefficient: 0.005,
					mieDirectionalG: 0.8,
					luminance: 1,
					inclination: 0.49, // elevation / inclination
					azimuth: 0.1,//0.25, // Facing front,
					sun: ! true
				};			   
				skyChange();

				// Show the progress of loading the models
				var callbackProgress = function( progress, result ) {

					var bar = 250;
					var total = progress.totalModels + progress.totalTextures;
					var loaded = progress.loadedModels + progress.loadedTextures;

					loadedmodel=loaded;
					totalmodel=total;

					total=total+totalshofar;
					loaded=loaded+loadedshofar;
					if ( total )
						bar = Math.floor( bar * loaded / total );


					$( "bar" ).style.width = bar + "px";

				};

				var callbackFinished = function ( result ) {
					if (loadedshofar==-2&&loadedmodel==-2) {
						$( "message" ).style.display = "none";
						$( "progressbar" ).style.display = "none";

						$( "progress" ).style.display = "none";
					}
				};

				$( "progress" ).style.display = "block";
				
				var shofarprogress= function ( item, loaded, total ) {
					var bar = 250;
					if (typeof loaded != "undefined") {
						loadedshofar=loaded;
						totalshofar=total;
						total=total+totalmodel;
						loaded=loaded+loadedmodel;
						if ( total )
							bar = Math.floor( bar * loaded / total );
						$( "bar" ).style.width = bar + "px";
					}
				};
				

			}

			// EVENT HANDLERS

			function onWindowResize( event ) {

				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;

				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

				camera.aspect = SCREEN_WIDTH/ SCREEN_HEIGHT;
				camera.updateProjectionMatrix();

			}

				
			// Change the sky based upon the inclination of the sun
			function skyChange() {
				var distance = 400000;

				var uniforms = sky.uniforms;
				uniforms.turbidity.value = effectController.turbidity;
				//uniforms.reileigh.value = effectController.reileigh;
				uniforms.luminance.value = effectController.luminance;
				uniforms.mieCoefficient.value = effectController.mieCoefficient;
				uniforms.mieDirectionalG.value = effectController.mieDirectionalG;

				var theta = Math.PI * (effectController.inclination - 0.5 );
				var phi = 2 * Math.PI * ( effectController.azimuth - 0.5 );

				sunSphere.position.x = distance * Math.cos( phi );
				sunSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
				sunSphere.position.z=  distance * Math.sin( phi ) * Math.cos( theta )

				sunSphere.visible = effectController.sun;

				sky.uniforms.sunPosition.value.copy( sunSphere.position );

				//renderer.render( scene, camera );

			}
			
			function cowSound()
			{
				var tick = system.currentMilliseconds();// d.getTime(); 
				if (cowtick==-1||cowtick-tick<0) {
					if (sound1.isPlaying)
						sound1.stop();
					cowtick=tick+4000+(Math.floor(Math.random()*20000)+1);
					var audioLoader = new THREE.AudioLoader();
					audioLoader.load( 'sounds/moo'+(Math.floor(Math.random()*3)+1)+'.mp3', function( buffer ) {
						sound1.setBuffer( buffer );
						sound1.setRefDistance( 20 );
						sound1.setVolume(0.1);						
						sound1.play();

					});
				}
			}
			
			
			function wingflap()
			{
				if (sound2.isPlaying) 
					sound2.stop();
				var audioLoader = new THREE.AudioLoader();
				audioLoader.load( 'sounds/flap'+(Math.floor(Math.random()*3)+1)+'.mp3', function( buffer ) {
					sound2.setBuffer( buffer );
					sound2.setRefDistance( 20 );
					sound2.setVolume(0.1);						
					sound2.play();
				});
			}
			
			function flyup()
			{
				if (cameraoffset<3) {
					cameraoffset+=0.1;
					space.objUpSurface(camera,cameraoffset);//camera.position.x+=0.01; //trick to show						
				}
				wingflap();
			}

			function flydown()
			{
				if (cameraoffset>0.15) {
					cameraoffset-=0.1;
					space.objUpSurface(camera,cameraoffset);//camera.position.x+=0.01; //trick to show
					wingflap();
				}
			}
			
			var prevlocalx;
			var prevlocaly;
			var prevlocalz;
			
			function animate() {
			
				requestAnimationFrame( animate );

				if (space) {
					prevlocalx=camera.position.x;
					prevlocaly=camera.position.y;
					prevlocalz=camera.position.z;
					frameTime = clock.getDelta();
					if (connect_state==CS_CONNECTED) {
						for (i=0; i<player_mixers.length; i++)
							player_mixers[i].update(frameTime);
					}					
					var Worldpos=space.localToWorldObj(camera);
					if (templestate==TS_SHOFAR) {
						if (mixershofar) {
							mixershofar.update(frameTime );
						}
						if (mixershofar2)
							mixershofar2.update(frameTime );
						if (Worldpos.x<4.6) {
							// Load the priest and remove the shofars when you get close
							templestate=TS_PRIEST;
							scene.remove(shofar);
							scene.remove(shofar2);
							scene.remove(lightshofar);
							
							var geometry = new THREE.PlaneBufferGeometry( 16000, 16000 );
							var material = new THREE.MeshPhongMaterial( { emissive: 0x220000 } );
							var loader = new THREE.JSONLoader();
							loader.load( "actors/priest/priest.json", function ( geometry, materials ) {
								for ( var k in materials ) {

									materials[k].skinning = true;

								}
								priest = new THREE.SkinnedMesh(geometry,new THREE.MultiMaterial(materials));
								priest.scale.set( 0.004, 0.004, 0.004);

								space.worldToLocalSurfaceObj(priest,-0.12,1.3,/*3.42+*/0.15);

								priest.skeleton.useVertexTexture = false;
								space.objTurn(priest,90);
								scene.add( priest );
								mixerpriest = new THREE.AnimationMixer( priest );
								mixerpriest.clipAction( priest.geometry.animations[3] ).clampWhenFinished=true;
								mixerpriest.clipAction( priest.geometry.animations[3] ).play();
									
							}
							
							);	
						}
						
						
					} else if (templestate==TS_PRIEST && mixerpriest) {
						mixerpriest.update(frameTime);
						if (Worldpos.x<1) {
							// When get close to the priest play his blessing
							templestate=TS_PRIEST_BLESSING;
							var audioLoader = new THREE.AudioLoader();

							audioLoader.load( 'sounds/blessing.mp3', function( buffer ) {
								sound2.setBuffer( buffer );
								sound2.setRefDistance( 20 );
								sound2.setVolume(0.2);						
								//sound1.play();
								osound.playFade(sound1,sound2,1);
								sound2.source.onended = function() {
									if (templestate==TS_PRIEST_BLESSING) {
										mixerpriest.clipAction( priest.geometry.animations[0] ).setDuration(0.95).setLoop(THREE.LoopOnce);//setEffectiveTimeScale(-1);
										mixerpriest.clipAction( priest.geometry.animations[0] ).reset();
										mixerpriest.clipAction( priest.geometry.animations[0] ).clampWhenFinished=true;
										mixerpriest.clipAction( priest.geometry.animations[0] ).play();
										mixerpriest.addEventListener('finished',function(e){
											if (templestate==TS_PRIEST_BLESSING) {
												mixerpriest.clipAction( priest.geometry.animations[3] ).play();
											}
										});								
									}
									this.isPlaying = false; /* sets Three wrapper property correctly */
									//alert('endedi');
								};
								
							});
							mixerpriest.clipAction( priest.geometry.animations[2] ).clampWhenFinished=true;
							mixerpriest.clipAction( priest.geometry.animations[2] ).setLoop(THREE.LoopOnce).play();						
							mixerpriest.clipAction( priest.geometry.animations[3] ).stop();
							mixerpriest.addEventListener('finished',function(e){							
								if (templestate==TS_PRIEST_BLESSING) {
									mixerpriest.clipAction( priest.geometry.animations[1] ).play();
								}

							}); 						
						}
						
					} else if (templestate==TS_PRIEST_BLESSING) {
						mixerpriest.update(frameTime);
						if (Worldpos.x>1.8) {
							// When leave the priest show the cow
							templestate=TS_COW;
							scene.remove(priest);
							var loader = new THREE.JSONLoader();
							loader.load( "actors/cow/cow.json", function ( geometry, materials ) {
								for ( var k in materials ) {

									materials[k].skinning = true;

								}
								cow = new THREE.SkinnedMesh(geometry,new THREE.MultiMaterial(materials));
								cow.createdtick= system.currentMilliseconds();
								cow.scale.set( 0.005, 0.005, 0.005);

								space.worldToLocalSurfaceObj(cow,3,2.4,0);//0.14);//3.45);//-0.12,1.5,3.42);

								cow.skeleton.useVertexTexture = false;
								
								scene.add( cow );
								mixercow = new THREE.AnimationMixer( cow );
								mixercow.clipAction( cow.geometry.animations[0] ).setDuration(10).play();
								  
				
												}
									
							);	
						}
						
					} else if (templestate==TS_COW) {
						if (mixercow) {
							if ( system.currentMilliseconds()-cow.createdtick>20000) {
								templestate=TS_COW_REMOVE;
							} else {
								mixercow.update(frameTime );
								cowSound();

							}
						}

					} else if (templestate==TS_COW_REMOVE) {
						// Wait till looking away to remove cow
						var angletocow=space.getAngleBetweensObjs(camera,cow);
						var anglecamera=space.getObjTurn(camera);
						var anglediff=Math.abs(omath.angleDifference(angletocow, anglecamera));
						//console.log('sound1 ended'+anglediff);
						if (anglediff>90) {
							templestate=TS_ARK_ADD;
							scene.remove(cow);
						} else
							cowSound();
						
					} else if (templestate==TS_ARK_ADD) {
						// Wait till looking away to remove
						var pos1=space.localToWorldObj(camera);
						var pos2=new THREE.Vector3(3.2,1.5,0);
						var angletoark=omath.getAngleBetweenPoints(pos1,pos2);
						var anglecamera=space.getObjTurn(camera);
						var anglediff=Math.abs(omath.angleDifference(angletoark, anglecamera));
						if (anglediff>90) {
							// Add the ark then the flares
							templestate=TS_ARK_FLARE_ADD;

							cubeCamera2 = new THREE.CubeCamera( 1, 1000, 256 );
							cubeCamera2.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
							space.worldToLocalSurfaceObj(cubeCamera2,7.7,1.2,0.0);
							scene.add( cubeCamera2 );	
							umaterial = new THREE.MeshBasicMaterial( {
								envMap: cubeCamera2.renderTarget.texture
							} );
							var objLoader = new THREE.OBJLoader();
							//objLoader.setMaterial( umaterial);
							objLoader.setPath( 'models/ark/' );
							objLoader.load( 'ark.obj', function (object) {
								ark=object;
								space.worldToLocalSurfaceObj(ark,3.2,1.5,0.0);
								//iobject.scale.set( 0.015, 0.015, 0.015);
								ark.scale.set( 0.15, 0.15, 0.15);
								
								ark.children[ 0].material=umaterial;
								scene.add( ark );
								ark.createdtick=system.currentMilliseconds();
								templestate=TS_ARK_FLARE_ADD2;
								
							}
							);	
						}
					} else if (templestate==TS_ARK_FLARE_ADD2) {

						if (system.currentMilliseconds()-ark.createdtick>4000) {
							templestate=TS_ARK;
							scene.remove(fire.mesh);
							
							// Show the flares
							var textureLoader = new THREE.TextureLoader();
							flareA = textureLoader.load( "models/ark/lensflare2.jpg" );
							flareB = textureLoader.load( "models/ark/lensflare0.png" );
							var fct=0.03;
							var sa = 2*fct, sb = 5*fct;
							
							fct=0.02;
							var params  = {

								"a" : { map: flareA, color: 0xffffff, blending: THREE.AdditiveBlending },
								"b" : { map: flareB, color: 0xffffff, blending: THREE.AdditiveBlending },

								"ar" : { map: flareA, color: 0xff0000, blending: THREE.AdditiveBlending },
								"br" : { map: flareB, color: 0xff0000, blending: THREE.AdditiveBlending }

							};

							var flares = [
								// front
								[ "a", sa, [ 47, 38, 120 ] ], [ "a", sa, [ 40, 38, 120 ] ], [ "a", sa, [ 32, 38, 122 ] ],
								[ "b", sb, [ 47, 38, 120 ] ], [ "b", sb, [ 40, 38, 120 ] ], [ "b", sb, [ 32, 38, 122 ] ],
								[ "a", sa, [ -47, 38, 120 ] ], [ "a", sa, [ -40, 38, 120 ] ], [ "a", sa, [ -32, 38, 122 ] ],
								[ "b", sb, [ -47, 38, 120 ] ], [ "b", sb, [ -40, 38, 120 ] ], [ "b", sb, [ -32, 38, 122 ] ],
								// back
								[ "ar", sa, [ 22, 50, -123 ] ], [ "ar", sa, [ 32, 49, -123 ] ],
								[ "br", sb, [ 22, 50, -123 ] ], [ "br", sb, [ 32, 49, -123 ] ],
								[ "ar", sa, [ -22, 50, -123 ] ], [ "ar", sa, [ -32, 49, -123 ] ],
								[ "br", sb, [ -22, 50, -123 ] ], [ "br", sb, [ -32, 49, -123 ] ],
							];

							for ( var i = 0; i < flares.length; i ++ ) {

								var p = params[ flares[ i ][ 0 ] ];

								var s = flares[ i ][ 1 ];

								var x = flares[ i ][ 2 ][ 0 ]*fct;
								var y = flares[ i ][ 2 ][ 1 ]*fct;
								var z = flares[ i ][ 2 ][ 2 ]*fct;

								var material = new THREE.SpriteMaterial( p );
								var sprite = new THREE.Sprite( material );

								var spriteWidth = 128;
								var spriteHeight = 128;

								sprite.scale.set( s * spriteWidth, s * spriteHeight, s );
								sprite.position.set( x, y, z );

								ark.children[0].add( sprite );

								sprites.push( sprite );
								//iobject.renderOrder=0;

							}

							scene.add(shofar);
							space.worldToLocalSurfaceObj(shofar,3.2,2.1,0.14);
							scene.add(shofar2);
							space.worldToLocalSurfaceObj(shofar2,3.2,0.8,0.14);
							animateShofar();
							
							// Once the ark appears let people fly
							$( "fly" ).style.display = "";

					        $( "flyup" ).addEventListener( 'click', flyup);//function() {
					        $( "flyup" ).addEventListener( 'touchstart', flyup);//function() {
							$( "flydown" ).addEventListener( 'click', flydown);//
							$( "flydown" ).addEventListener( 'touchstart', flydown);//
				
							
						}
					
					
					} else if (templestate==TS_ARK) {
						mixershofar.update(frameTime );
						mixershofar2.update(frameTime );

					} 
					if (joystick)
						joystick.update();
					osound.update();
						
					effectController.inclination+=frameTime*0.01;
					skyChange();
					if (fire)
						fire.update( clock.getElapsedTime());
						
					// Flicker the spot light on the temple slightly
					if (light) {
						light.intensity += frameTime*(5*Math.random()-2.5);//= 2+Math.random()*0.1-0.05;
						if (light.intensity>2.3)
							light.intensity=2.3;
						else if (light.intensity<1.7)
							light.intensity=1.7;
					}
				}
				render();

	
			}
				
			var inc=0;
			
			function render() {
				if (stats)
                	stats.update();
				var delta = clock.getDelta();

				// Test hit a wall and if so go back
				if (space&&(prevlocalx!=camera.position.x||prevlocalz!=camera.position.z)) {
					// calculate objects intersecting the picking ray
					if (typeof space._surface != "undefined"&&typeof space._surface.children != "undefined"&&typeof space._walls != "undefined"&&typeof space._walls.children != "undefined") {
						var distintersect=space.wallIntersectDistance(camera.position.x,camera.position.y,camera.position.z, prevlocalx, prevlocaly, prevlocalz)
						var dostop=	distintersect>=0&& distintersect<0.3;
						if (!dostop) {
							// dont walk into the ark
							if (ark) {
								dostop=space.getDistanceBetweenObjs(camera,ark)<0.2;
							}
						}
						if (dostop){
							camera.position.x=prevlocalx;
							camera.position.z=prevlocalz;
						} else {

						}

					} else {
						prevlocalx=-1;
					}
				}
				// Update the ark texture every 25 frames
				if (cubeCamera2&&ark&&inc%25==0){
					umaterial.envMap = cubeCamera2.renderTarget.texture;
					umaterial.color.setHex(0xffff66);
					cubeCamera2.updateCubeMap( renderer, scene );
				}
 				renderer.render( scene, camera );
				inc++;
			}


	
var poll=1000;  // How often you poll the server
var msgs=[];
var max_message=5;  // How many messages you show
var whos=[];

var removed_horn=false;

// Remove the horn from the shofar
// Is the first 89 faces
function remove_horn(obj)
{
	for (i=0; i<89; i++) {

	    obj.geometry.faces.shift();
	    obj.geometry.faces.shift();
	    obj.geometry.faceVertexUvs[0].shift();
	    obj.geometry.faceVertexUvs[0].shift();
	}
	//obj.geometry.verticesNeedUpdate=true;
	obj.geometry.elementsNeedUpdate=true;
	//obj.geometry.uvsNeedUpdate=true;
}

// from the seed of the username get a repeatable random color
function colorFromName(text)
{
	var seed=0;
	for (kk=0; kk<text.length; kk++) {
		seed+=(kk+1)*text.charCodeAt(kk);
	}
	var letters='0123456789ABCDEF';
	var color='#';
	for (var i=0; i<6; i++) {
	    var x = Math.sin(seed++) * 10000;
	    var rand= x - Math.floor(x);
        //alert(rand);
		color+=letters[Math.floor(rand*16)];
	}
	return color;
}

var lastconnection=-1;

setInterval(function(){

	if (space&&connect_state==CS_CONNECTED||connect_state==CS_CONNECTING) {
		var pos=space.localToWorldObj(camera);

        var commands=[];
        if (camera._who)
        	commands.push("who");
        if (camera._disconnect)
        	commands.push("disconnect");
        if (connect_state==CS_CONNECTING)
        	commands.push("connecting");
        for (i=0; i<camera._msg.length; i++)
        	camera._msg[i]=camera._name+" says:"+camera._msg[i];
		var position= [{  
		    "name" : camera._name,
		    "x" : pos.x ,
		    "y" : pos.y ,
		    "z" : 0 ,
		    "turn": space.getObjTurn(camera),
		    "action": camera._action,
		    "msg": camera._msg,
		    "commands": commands
		   // "who": camera._who,
           // "disconnect": camera._disconnect
		}]; 
		if (camera._disconnect) {
			disconnect();

		}
		camera._action="";
		camera._msg=[];
		camera._who=0;
		camera._disconnect=0;
		// If over 10 seconds that got a response from server then display disconnect icon
		if (connect_state==CS_CONNECTED&&lastconnection>0&&system.currentMilliseconds()-lastconnection>10000)
			$("disconnect").style.display="inline";
		else
			$("disconnect").style.display="none";
		// commands who, connect, disconnect
		// Why do I need to do this when I call remove_horn?
		shofar.geometry.elementsNeedUpdate=false;
		var xmlhttp=new XMLHttpRequest();
		xmlhttp.onreadystatechange =function()
		{
			if (xmlhttp.readyState==4 && xmlhttp.status!=200) {
	
			} else if (xmlhttp.readyState==4 && xmlhttp.status==200) {
				if (xmlhttp.responseText=="") {
					return; 
				}
				lastconnection=system.currentMilliseconds();

				if (connect_state==CS_CONNECTING) {
					// user has connected
					connect_state=CS_CONNECTED;
					$("promptext").innerHTML="Connected";
					setTimeout(has_connected(),1000);

					if (!removed_horn) {
						remove_horn(shofar);
						//remove_horn(shofar2);
						removed_horn=true;
					}
					//
				}
				try {
                	ret=JSON.parse(xmlhttp.responseText);
                } catch(e) {
                	alert(e+" "+xmlhttp.responseText);
                }
                data=ret["users"];
				
				if (ret["who"]) {
					whos=ret["who"];
				}
				// Move to where the server says to if told to
				if (ret["player_pos"]) {
					space.worldToLocalSurfaceObj(camera,ret["player_pos"][0],ret["player_pos"][1],cameraoffset);
				}
				color=colorFromName(camera._name);
				$("wholist").innerHTML="You: <span style='color:"+color+"'>"+camera._name+"</span><br>"+
				                       "Num Playing :"+ret["num_players"];//html(
				if (whos.length>0) {
					$("wholist").innerHTML+= "<br>Players on:<br>"
					for (i=0; i<whos.length; i++) {
						color=colorFromName(whos[i]);

						$("wholist").innerHTML+= "<div style='color:"+color+"'>"+whos[i]+"</div>";//<br>";

					}
				}

				msgs=msgs.concat(ret["msg"]);
				if (msgs.length>max_message) {
					msgs.splice(0,msgs.length-max_message-1);

				}
				// if a player is no longer on the server remove them
				for (i=player_mixers.length-1; i>=0; i--) {
					var gone=true;
					for (j=0; j<data.length; j++) {
						if (player_mixers[i]._userid==data[j][0])
							gone=false;
					}

					if (gone){//player_mixers[i]._gone) {
						scene.remove(player_mixers[i]._root);
						player_mixers_removed.push(player_mixers[i]);
						player_mixers.splice(i,1);
					}

				}

				for (i=0; i<data.length; i++) {
					// go through each player from server
					var player;
					// find the player in your list of current players
					var found_player=false;
					for (j=0; j<player_mixers.length; j++) {
						if (player_mixers[j]._userid==data[i][0]||!player_mixers[j]._userid) {
							player=player_mixers[j];
							if (player_mixers[j]._userid==data[i][0])
								found_player=true;
						}
					}
					// if cant find the player either reuse a removed player or create a new one
					if (!player) {
						if (player_mixers_removed.length>0) {
							// reuse an old player if one around
							player=player_mixers_removed[0];

							player_mixers_removed.splice(0,1);
						} else  {
							//alert('clone');
							var _has_name;
							if ((player_mixers.length) % 3==0) {
								//shofar.remove(player_mixers[0]._has_name); // so dont get two - add and delete sprite
								player_model=shofar.clone();
								//shofar.add(player_mixers[0]._has_name);

							} else if ((player_mixers.length) % 3==1) {
							   // shofar2.remove(player_mixers[1]._has_name); // so dont get two - add and delete sprite
								player_model=shofar2.clone();
								//shofar2.add(player_mixers[1]._has_name);
							} else  {
								if (player_mixers.length==2) {
								  //  shofar.remove(player_mixers[0]._has_name); // so dont get two - add and delete 
									player_model=shofar.clone();
     								//shofar.add(player_mixers[0]._has_name);
									texture=THREE.ImageUtils.loadTexture("actors/shofar/shofar3.jpg");
									player_model.material=shofar.material.clone();
									player_model.material.materials[0]=new THREE.MeshLambertMaterial({map:texture});
									player_model.material.materials[0].skinning=true;
							    } else 
							    	player_model=player_mixers[2].clone();
							}
							player = new THREE.AnimationMixer( player_model);
						}
						scene.add(player._root);
						player_mixers.push(player);
					}
					var changed_sprite=false;
					if (!found_player||player._name!=data[i][1]) {
						// If reusing old player then remove old name 
						for (kk=player._root.children.length-1; kk>=0; kk--)
							if (player._root.children[kk] instanceof THREE.Sprite)
								player._root.remove(player._root.children[kk]);

						color=colorFromName(data[i][1]);
						var spritey = makeTextSprite( data[i][1], 
							{ fontsize: 24, borderColor: {r:0, g:0, b:0, a:0}, backgroundColor: {r:55, g:00, b:00, a:0} },color );

					
						player._root.add( spritey );
						player._has_name=spritey;
						changed_sprite=true;

					}

                    x=parseFloat(data[i][2]);
                    y=parseFloat(data[i][3]);
                    z=parseFloat(data[i][4]);
                    playerpos=space.localToWorldObj(player._root);
                    player._userid=data[i][0];
                    player._name=data[i][1];
					if (!changed_sprite) {
						// if existing player has moved then lerp the player to the new location
	                    var stopdist=0.01;
	                    dist=omath.vectorDistance(new THREE.Vector3(x,y,0.14),playerpos);
	                    if (dist>stopdist&&!player._isWalking) {
	                    	player._isWalking=true;
							player.clipAction( player._root.geometry.animations[3] ).stop();
							player.clipAction( player._root.geometry.animations[4] ).reset();
							player.clipAction( player._root.geometry.animations[4] ).play();

						} else if (dist<stopdist&&player._isWalking) {
	                    	player._isWalking=false;
							player.clipAction( player._root.geometry.animations[4] ).stop();
							player.clipAction( player._root.geometry.animations[3] ).reset();
							player.clipAction( player._root.geometry.animations[3] ).play();

						}
						space.worldToLocalSurfaceObjLerp(player._root,x,y,0.14,poll/1000);
				    } else {
				    	// if player has entered the game then move them straight there
				    	animationstop(player);

				    	//player.clipAction( player._root.geometry.animations[3] ).reset();
						player.clipAction( player._root.geometry.animations[3] ).play();
						space.worldToLocalSurfaceObj(player._root,x,y,0.14);
				    }

					action=data[i][6];
                    if (action=="wave") {
                    	player._isWalking=false;
                    	animationstop(player);
						player.clipAction( player._root.geometry.animations[5] ).setDuration(2).setLoop(THREE.LoopOnce).play();
						player.addEventListener('finished',function(e){
							player.clipAction( player._root.geometry.animations[3] ).reset();
							player.clipAction( player._root.geometry.animations[3] ).play();
						});							

                    }
					var turn=parseFloat(data[i][5]);
					space.objTurn(player._root,turn);
					
				}

				var msglines="";
				for (i=0; i<msgs.length; i++) {
					if (msgs[i][0]>=0) {
						var usename="";
						for (j=0; j<player_mixers.length; j++)
							if (player_mixers[j]._userid==msgs[i][0])
								usename=player_mixers[j]._name;
						if (!usename)
							usename=camera._name; // if cannot find on a player must be the user himself
						color=colorFromName(usename);
						msglines=msglines+"<span style='color:"+color+"'>"+msgs[i][1]+"</span><br>";
	
					} else 
						msglines=msglines+msgs[i][1]+"<br>";
				}
				$("messages").innerHTML=msglines;

			}
		}
		xmlhttp.open("POST","server/secondtemple.php",true);
		xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
		xmlhttp.setRequestHeader("Cache-Control","no-cache");
		xmlhttp.send("position=" +JSON.stringify(position));

	}
}, poll);	
	

	
</script>
<!-- Piwik -->
<script type="text/javascript">
  var _paq = _paq || [];
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//secondtemple.org/piwik/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', 1]);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript><p><img src="//secondtemple.org/piwik/piwik.php?idsite=1" style="border:0;" alt="" /></p></noscript>
<!-- End Piwik Code -->			

	</body>
</html>
